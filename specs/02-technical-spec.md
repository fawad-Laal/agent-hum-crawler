# Technical Spec - Dynamic Monitoring Agent

Date: 2026-02-18
Version: 0.2 (MVP)

## 1. Architecture Overview
Components:
- Intake layer: collects runtime config from user.
- Monitoring layer: gathers and normalizes online updates.
- Intelligence layer: severity/confidence classification + dedupe/change detection.
- Alert layer: formats and posts Moltis chat alerts.
- State layer: stores cycle state (hashes, timestamps, prior summaries).

## 2. Runtime Configuration Model

```json
{
  "countries": ["Pakistan", "Bangladesh"],
  "disaster_types": ["cyclone/storm", "flood", "earthquake"],
  "check_interval_minutes": 30,
  "subregions": {
    "Pakistan": ["Sindh"]
  },
  "priority_sources": [],
  "quiet_hours_local": null
}
```

Validation:
- `countries.length >= 1`
- `disaster_types.length >= 1`
- `check_interval_minutes` in [5, 1440]

## 3. Event Data Model

```json
{
  "event_id": "hash(country+region+type+headline+date)",
  "country": "Pakistan",
  "subregion": "Sindh",
  "disaster_type": "flood",
  "severity": "high",
  "confidence": "medium",
  "summary": "River overflow warning expanded to ...",
  "impact": "Road closures in ...",
  "sources": [
    {"url": "https://...", "published_at": "2026-02-17T15:10:00Z", "source_type": "official"}
  ],
  "updated_at": "2026-02-17T15:15:00Z",
  "status": "new"
}
```

## 4. Monitoring Workflow
1. Load config/state.
2. Query source set by country/disaster filters.
3. Normalize candidates into event model.
4. Score severity and confidence.
5. Dedupe using hash + fuzzy match on summary/region/time.
6. Compare to last cycle (`new`, `updated`, `unchanged`).
7. Emit alerts by rule.
8. Persist cycle state and next check timestamp.

## 5. Alert Emission Rules
- Emit: all `high` and `critical`.
- Emit: `medium` only if `status` is `new` or meaningful `updated`.
- Skip: unchanged `medium`, most `low` items (store as watchlist only).

## 6. Storage and State
- Config path: `~/.config/moltis/moltis.toml`
- Key store: `~/.config/moltis/provider_keys.json`
- Data path: `~/.moltis/`
- Agent-specific state fields:
  - `last_cycle_hashes`
  - `last_run_at`
  - `last_summary`

## 7. Error Handling
- If source fetch fails: log source error, continue with remaining sources.
- If no reliable sources found: output "insufficient verification" with confidence `low`.
- If provider unavailable: skip cycle and retry next interval.

## 8. Security and Safety Controls
- No autonomous external actions.
- No emergency instructions without source attribution.
- Explicit warning for life-threatening situations.
- Prefer read-only operations where possible.

## 9. Observability
Per cycle capture:
- run start/end time
- sources queried and success/fail counts
- events generated by severity
- alerts emitted count
- deduped count

## 10. Open Technical Decisions
- Exact source connector strategy (RSS/APIs/scrape mix)
- Fuzzy-match threshold for near-duplicates
- Quiet-hours behavior for critical events (likely always notify)

## 11. Moltis Prompt Architecture Alignment
- Use Moltis dynamic system prompt assembly as primary orchestration layer (identity, soul, user profile, project context, runtime context, skills, tools, guidelines).
- Keep agent guidance in project `AGENTS.md`; keep user-level persona files in `~/.moltis/`:
  - `IDENTITY.md`
  - `SOUL.md`
  - `USER.md`
  - optional `TOOLS.md`
- Ensure prompt instructions emphasize:
  - API-first collection for trusted sources.
  - Browser automation only when API/RSS is unavailable or insufficient.
  - source attribution and uncertainty language for all alerting.

## 12. Streaming and Tool-Loop Behavior
- Operate with Moltis streaming mode enabled so users receive token deltas during long runs.
- Preserve tool-call accumulation + parallel execution semantics for multi-source fetch steps.
- Keep alert responses concise while tool execution state is surfaced through streaming events (`thinking`, `tool_call_start`, `tool_call_end`, `delta`).

## 13. Collection Strategy in Moltis
- Preferred order:
  1. Official APIs (ReliefWeb and similar).
  2. Stable RSS/Atom feeds (government, UN, NGO, local news).
  3. Browser automation for JavaScript-heavy or blocked content.
- Browser usage policy:
  - enable domain allowlists for trusted domains where possible.
  - prefer sandboxed browser sessions when available.
  - store extracted body text in `rawitemrecord.payload_json.text`.

## 14. Observability Requirements (Moltis + App)
- Keep app-level quality commands (`quality-report`, `source-health`, `hardening-gate`, `pilot-run`) as operator-facing QA controls.
- Enable Moltis metrics/tracing in gateway deployment for runtime observability:
  - `/metrics` Prometheus endpoint
  - `/api/metrics`, `/api/metrics/summary`, `/api/metrics/history`
- Minimum operational dashboards:
  - LLM request latency and token usage.
  - Tool execution error rates.
  - Browser/session failures.
  - Connector/feed health from app DB outputs.

## 15. Authentication and Security Baseline
- For any non-local deployment, require Moltis auth enabled (`auth.disabled = false`).
- Use scoped API keys only; enforce least-privilege permissions for integrations.
- Prefer passkey-enabled operator access for admin functions.
- In reverse proxy deployments, set `MOLTIS_BEHIND_PROXY=true` unless equivalent remote classification guarantees are verified.
- Keep command approvals in `smart` (or stricter) mode and sandbox execution enabled.
- Apply third-party skills trust lifecycle controls and monitor security audit logs.

## 16. Streaming and Tool Registry Baseline
- Preserve Moltis streaming event contract and surface incremental updates in chat.
- Keep tool-call lifecycle visibility (`tool_call_start`/`tool_call_end`) for long workflows.
- Monitor streaming performance risks from frequent delta rendering and slow websocket clients.
- Use source-aware registry filtering for MCP controls (`builtin` vs `mcp`), avoiding name-prefix heuristics.
